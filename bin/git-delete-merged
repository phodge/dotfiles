#!/usr/bin/env python3
import subprocess

import click
import git


def _run(cmd):
    return subprocess.check_output(cmd).decode('utf-8')


def _get_refs():
    local = set()
    remote = {}
    tags = set()

    # get a list of local branches, remote branches, and tags
    for line in _run(['git', 'show-ref']).splitlines():
        sha, ref = line.split(' ')
        assert ref.startswith('refs/'), ref
        if ref.startswith('refs/heads/'):
            local.add(ref[11:])
        elif ref.startswith('refs/tags/'):
            tags.add(ref[10:])
        elif ref.startswith('refs/remotes/'):
            if not ref.endswith('/HEAD'):
                name, branch = ref[13:].split('/')
                remote.setdefault(name, set()).add(branch)
        elif ref == 'refs/stash':
            continue
        else:
            raise Exception("Unexpected ref %r" % ref)

    return local, remote, tags


def _examine_local(repo, l, local, remote, localmaster):
    # if we have a local master branch, check the branch against that first
    if localmaster and _attempt_removal(repo, l, None, 'master'):
        return

    # check this local branch against all the remote masters next
    for rname, rbranches in remote.items():
        if ('master' in rbranches and
                _attempt_removal(repo, l, rname, 'master')):
            return

    # next, check the local branch against all the other local branches
    for otherl in local:
        if otherl != l and otherl != 'master':
            if _attempt_removal(repo, l, None, otherl):
                return

    # next, check the local branch against all the other remote branches
    for rname, rbranches in remote.items():
        for rbranch in rbranches:
            if rbranch != 'master':
                if _attempt_removal(repo, l, rname, rbranch):
                    return


def _attempt_removal(repo, local, remotename, other):
    if remotename is None:
        otherref = other
    else:
        otherref = "/".join((remotename, other))

    current = None if repo.head.is_detached else repo.active_branch.name

    # don't remove the current branch if it's only pushed upstream
    if local == current and local == other:
        return False

    # is it an ancestor?
    merge_base = _run(['git', 'merge-base', local, otherref]).strip()
    sha = _run(['git', 'rev-parse', '--verify', local]).strip()
    if sha == merge_base:
        msg = "{} is merged to {}. Delete it?".format(local, otherref)

        if click.confirm(msg, default=False):
            # do we need to jump to another branch first?
            if current == local:
                # jump to the other thing first
                _run(['git', 'checkout', otherref])

            click.echo("Deleting local branch {} (was at {})."
                       .format(local, sha))
            _run(['git', 'branch', '-D', local])
        return True
    return False


@click.command()
def main():
    # what's the current branch name?
    repo = git.Repo()

    local, remote, _ = _get_refs()

    localmaster = 'master' in local
    if localmaster:
        # never try to clean up 'master'
        local.remove('master')

    while len(local):
        # grab a random branch to examine
        l = local.pop()
        _examine_local(repo, l, local, remote, localmaster)


if __name__ == '__main__':
    main()
